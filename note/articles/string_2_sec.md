---
title: "C言語のバッファオーバーフローとセキュリティリスク"
emoji: "🔒"
type: "tech"
topics: ["c", "security", "programming"]
published: false
---

# C言語のバッファオーバーフローとセキュリティリスク

## はじめに

C言語の配列操作を実験していて、配列のサイズを超えてアクセスしても「なぜかエラーにならない」という現象に遭遇しました。これは実はセキュリティ上の重要な問題である**バッファオーバーフロー**の典型例です。

## 実験コードと結果

以下のコードを実行してみました：

```c
#include <stdio.h>
int main()
{
    char title[12] = "Holy Dragon";
    title[4] = '+';
    for (int i = 0; i < 20; i++)  // 配列サイズ12なのに20回ループ
    printf("%c,", title[i]);
    printf("\n");
}
```

**実行結果：**
```
H,o,l,y,+,D,r,a,g,o,n,,,),,~,>,,,2,
```
[title配列: 0-11][隣接メモリ領域: 12-19]
[正常なデータ]    [ゴミデータ・他の変数]

## セキュリティリスク

### 1. 情報漏洩（読み取り系）
```c
char password[8] = "secret";
char username[8];
// 攻撃者が長い範囲の読み取りを要求
for (int i = 0; i < 16; i++) {
    printf("%c", username[i]);  // passwordも出力される可能性
}
```

### 2. コード実行攻撃（書き込み系）
```c
char buffer[100];
gets(buffer);  // 危険！長すぎる入力でバッファオーバーフロー
```

**攻撃の流れ：**
1. 攻撃者が非常に長い文字列を送信
2. バッファを超えた部分が関数の戻りアドレスを上書き
3. 悪意のあるコードが実行される

## 対策方法

### 1. 境界チェックの実装
```c
// 危険
for (int i = 0; i < 20; i++)

// 安全
int len = strlen(title);
for (int i = 0; i < len; i++)
```

### 2. 安全な関数の使用
```c
// 危険な関数
gets(buffer);
strcpy(dest, src);

// 安全な関数
fgets(buffer, sizeof(buffer), stdin);
strncpy(dest, src, sizeof(dest) - 1);
```

### 3. コンパイラオプション
```bash
gcc -fstack-protector -D_FORTIFY_SOURCE=2 program.c
```

### 4. 現代的な言語の採用
- **Rust**：メモリ安全性を保証
- **Go**：境界チェック付き配列
- **Python**：動的型付けで安全

## 実際のセキュリティ事例

- **Heartbleed**：OpenSSLのバッファオーバーリード脆弱性
- **WannaCry**：SMBプロトコルのバッファオーバーフロー
- **Code Red**：IISのバッファオーバーフロー

## まとめ

C言語の「エラーにならない」現象は、実は重大なセキュリティリスクを含んでいます。

- 配列の境界を超えたアクセスは**未定義動作**
- 情報漏洩やコード実行攻撃の原因となる
- 適切な境界チェックと安全な関数の使用が必要
- 現代的な言語では多くの問題が解決されている

プログラミング学習では、「動く」ことと「安全」であることは別問題であることを常に意識することが重要です。
